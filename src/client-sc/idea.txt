public LayerMask groundLayer; // The Layer Ground
public Vector3 offset = Vector3.up;

private void Update()
{
    if (Physics.Raycast(transform.position, Vector3.down, out var groundHit, 2f, groundLayer.value))
    {
        var cross = Vector3.Cross(transform.right, groundHit.normal);

        var _lookRotation = Quaternion.LookRotation(cross, groundHit.normal);

        transform.position = groundHit.point + offset; // the offset is OPTIONAL, you can adjust it manuel or remove

        transform.rotation = _lookRotation;
    }
}

private static Quaternion QuaternionLookRotation(Vector3 forward, Vector3 up)
{
    forward.Normalize();

    Vector3 vector = Vector3.Normalize(forward);
    Vector3 vector2 = Vector3.Normalize(Vector3.Cross(up, vector));
    Vector3 vector3 = Vector3.Cross(vector, vector2);
    var m00 = vector2.x;
    var m01 = vector2.y;
    var m02 = vector2.z;
    var m10 = vector3.x;
    var m11 = vector3.y;
    var m12 = vector3.z;
    var m20 = vector.x;
    var m21 = vector.y;
    var m22 = vector.z;


    float num8 = (m00 + m11) + m22;
    var quaternion = new Quaternion();
    if (num8 > 0f)
    {
        var num = (float)Math.Sqrt(num8 + 1f);
        quaternion.w = num * 0.5f;
        num = 0.5f / num;
        quaternion.x = (m12 - m21) * num;
        quaternion.y = (m20 - m02) * num;
        quaternion.z = (m01 - m10) * num;
        return quaternion;
    }
    if ((m00 >= m11) && (m00 >= m22))
    {
        var num7 = (float)Math.Sqrt(((1f + m00) - m11) - m22);
        var num4 = 0.5f / num7;
        quaternion.x = 0.5f * num7;
        quaternion.y = (m01 + m10) * num4;
        quaternion.z = (m02 + m20) * num4;
        quaternion.w = (m12 - m21) * num4;
        return quaternion;
    }
    if (m11 > m22)
    {
        var num6 = (float)Math.Sqrt(((1f + m11) - m00) - m22);
        var num3 = 0.5f / num6;
        quaternion.x = (m10+ m01) * num3;
        quaternion.y = 0.5f * num6;
        quaternion.z = (m21 + m12) * num3;
        quaternion.w = (m20 - m02) * num3;
        return quaternion; 
    }
    var num5 = (float)Math.Sqrt(((1f + m22) - m00) - m11);
    var num2 = 0.5f / num5;
    quaternion.x = (m20 + m02) * num2;
    quaternion.y = (m21 + m12) * num2;
    quaternion.z = 0.5f * num5;
    quaternion.w = (m01 - m10) * num2;
    return quaternion;
}